/// <reference types="node" />
import type { Fetcher, FetcherRequestInit, FetcherResponse } from '@apollo/utils.fetcher';
import type { KeyValueCache } from '@apollo/utils.keyvaluecache';
import type { Logger } from '@apollo/utils.logger';
import type { WithRequired } from '@apollo/utils.withrequired';
import { GraphQLError } from 'graphql';
import type { Options as HttpCacheSemanticsOptions } from 'http-cache-semantics';
import { HTTPCache } from './HTTPCache';
export type ValueOrPromise<T> = T | Promise<T>;
export type RequestOptions<CO extends CacheOptions = CacheOptions> = FetcherRequestInit & {
    params?: Record<string, string | undefined> | URLSearchParams;
    cacheKey?: string;
    cacheOptions?: CO | ((url: string, response: FetcherResponse, request: RequestOptions<CO>) => ValueOrPromise<CO | undefined>);
    httpCacheSemanticsCachePolicyOptions?: HttpCacheSemanticsOptions;
};
export interface HeadRequest<CO extends CacheOptions = CacheOptions> extends RequestOptions<CO> {
    method?: 'HEAD';
    body?: never;
}
export interface GetRequest<CO extends CacheOptions = CacheOptions> extends RequestOptions<CO> {
    method?: 'GET';
    body?: never;
}
interface WithBody<CO extends CacheOptions = CacheOptions> extends Omit<RequestOptions<CO>, 'body'> {
    body?: FetcherRequestInit['body'] | object;
}
export interface PostRequest<CO extends CacheOptions = CacheOptions> extends WithBody<CO> {
    method?: 'POST';
}
export interface PutRequest<CO extends CacheOptions = CacheOptions> extends WithBody<CO> {
    method?: 'PUT';
}
export interface PatchRequest<CO extends CacheOptions = CacheOptions> extends WithBody<CO> {
    method?: 'PATCH';
}
export interface DeleteRequest<CO extends CacheOptions = CacheOptions> extends WithBody<CO> {
    method?: 'DELETE';
}
export type RequestWithoutBody<CO extends CacheOptions = CacheOptions> = HeadRequest<CO> | GetRequest<CO>;
export type RequestWithBody<CO extends CacheOptions = CacheOptions> = PostRequest<CO> | PutRequest<CO> | PatchRequest<CO> | DeleteRequest<CO>;
export type DataSourceRequest<CO extends CacheOptions = CacheOptions> = RequestWithoutBody<CO> | RequestWithBody<CO>;
export type AugmentedRequest<CO extends CacheOptions = CacheOptions> = (Omit<WithRequired<RequestWithoutBody<CO>, 'headers'>, 'params'> | Omit<WithRequired<RequestWithBody<CO>, 'headers'>, 'params'>) & {
    params: URLSearchParams;
};
export interface CacheOptions {
    ttl?: number;
}
export interface DataSourceConfig {
    cache?: KeyValueCache;
    fetch?: Fetcher;
    logger?: Logger;
}
export interface RequestDeduplicationResult {
    policy: RequestDeduplicationPolicy;
    deduplicatedAgainstPreviousRequest: boolean;
}
export interface HTTPCacheResult {
    cacheWritePromise: Promise<void> | undefined;
}
export interface DataSourceFetchResult<TResult> {
    parsedBody: TResult;
    response: FetcherResponse;
    requestDeduplication: RequestDeduplicationResult;
    httpCache: HTTPCacheResult;
}
export type RequestDeduplicationPolicy = {
    policy: 'deduplicate-during-request-lifetime';
    deduplicationKey: string;
} | {
    policy: 'deduplicate-until-invalidated';
    deduplicationKey: string;
} | {
    policy: 'do-not-deduplicate';
    invalidateDeduplicationKeys?: string[];
};
export declare abstract class RESTDataSource<CO extends CacheOptions = CacheOptions> {
    protected httpCache: HTTPCache<CO>;
    protected deduplicationPromises: Map<string, Promise<any>>;
    baseURL?: string;
    logger: Logger;
    constructor(config?: DataSourceConfig);
    protected cacheKeyFor(url: URL, request: RequestOptions<CO>): string;
    protected requestDeduplicationPolicyFor(url: URL, request: RequestOptions<CO>): RequestDeduplicationPolicy;
    protected willSendRequest?(path: string, requestOpts: AugmentedRequest<CO>): ValueOrPromise<void>;
    protected resolveURL(path: string, _request: AugmentedRequest<CO>): ValueOrPromise<URL>;
    protected cacheOptionsFor?(url: string, response: FetcherResponse, request: FetcherRequestInit): ValueOrPromise<CO | undefined>;
    protected didEncounterError(_error: Error, _request: RequestOptions<CO>, _url?: URL): void;
    protected parseBody(response: FetcherResponse): Promise<object | string>;
    private cloneDataSourceFetchResult;
    protected cloneParsedBody<TResult>(parsedBody: TResult): TResult;
    protected shouldJSONSerializeBody(body: RequestWithBody<CO>['body']): boolean;
    protected throwIfResponseIsError(options: {
        url: URL;
        request: RequestOptions<CO>;
        response: FetcherResponse;
        parsedBody: unknown;
    }): Promise<void>;
    protected errorFromResponse({ response, parsedBody, }: {
        url?: URL;
        request?: RequestOptions<CO>;
        response: FetcherResponse;
        parsedBody: unknown;
    }): Promise<GraphQLError>;
    protected head(path: string, request?: HeadRequest<CO>): Promise<FetcherResponse>;
    protected get<TResult = any>(path: string, request?: GetRequest<CO>): Promise<TResult>;
    protected post<TResult = any>(path: string, request?: PostRequest<CO>): Promise<TResult>;
    protected patch<TResult = any>(path: string, request?: PatchRequest<CO>): Promise<TResult>;
    protected put<TResult = any>(path: string, request?: PutRequest<CO>): Promise<TResult>;
    protected delete<TResult = any>(path: string, request?: DeleteRequest<CO>): Promise<TResult>;
    private urlSearchParamsFromRecord;
    fetch<TResult>(path: string, incomingRequest?: DataSourceRequest<CO>): Promise<DataSourceFetchResult<TResult>>;
    protected catchCacheWritePromiseErrors(cacheWritePromise: Promise<void>): void;
    protected trace<TResult>(url: URL, request: RequestOptions<CO>, fn: () => Promise<TResult>): Promise<TResult>;
}
export {};
//# sourceMappingURL=RESTDataSource.d.ts.map