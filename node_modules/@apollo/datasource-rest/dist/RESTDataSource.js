"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RESTDataSource = void 0;
const graphql_1 = require("graphql");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const lodash_isplainobject_1 = __importDefault(require("lodash.isplainobject"));
const HTTPCache_1 = require("./HTTPCache");
const NODE_ENV = process.env.NODE_ENV;
class RESTDataSource {
    constructor(config) {
        var _a;
        this.deduplicationPromises = new Map();
        this.httpCache = new HTTPCache_1.HTTPCache(config === null || config === void 0 ? void 0 : config.cache, config === null || config === void 0 ? void 0 : config.fetch);
        this.logger = (_a = config === null || config === void 0 ? void 0 : config.logger) !== null && _a !== void 0 ? _a : console;
    }
    cacheKeyFor(url, request) {
        var _a, _b;
        return (_a = request.cacheKey) !== null && _a !== void 0 ? _a : `${(_b = request.method) !== null && _b !== void 0 ? _b : 'GET'} ${url}`;
    }
    requestDeduplicationPolicyFor(url, request) {
        var _a;
        const method = (_a = request.method) !== null && _a !== void 0 ? _a : 'GET';
        const cacheKey = this.cacheKeyFor(url, request);
        if (['GET', 'HEAD'].includes(method)) {
            return {
                policy: 'deduplicate-during-request-lifetime',
                deduplicationKey: cacheKey,
            };
        }
        else {
            return {
                policy: 'do-not-deduplicate',
                invalidateDeduplicationKeys: [
                    this.cacheKeyFor(url, { ...request, method: 'GET' }),
                    this.cacheKeyFor(url, { ...request, method: 'HEAD' }),
                ],
            };
        }
    }
    resolveURL(path, _request) {
        return new URL(path, this.baseURL);
    }
    didEncounterError(_error, _request, _url) {
    }
    parseBody(response) {
        const contentType = response.headers.get('Content-Type');
        const contentLength = response.headers.get('Content-Length');
        if (response.status !== 204 &&
            contentLength !== '0' &&
            contentType &&
            (contentType.startsWith('application/json') ||
                contentType.endsWith('+json'))) {
            return response.json();
        }
        else {
            return response.text();
        }
    }
    cloneDataSourceFetchResult(dataSourceFetchResult, requestDeduplicationResult) {
        return {
            ...dataSourceFetchResult,
            requestDeduplication: requestDeduplicationResult,
            parsedBody: this.cloneParsedBody(dataSourceFetchResult.parsedBody),
        };
    }
    cloneParsedBody(parsedBody) {
        return (0, lodash_clonedeep_1.default)(parsedBody);
    }
    shouldJSONSerializeBody(body) {
        var _a;
        return !!((Array.isArray(body) ||
            (0, lodash_isplainobject_1.default)(body) ||
            (body &&
                typeof body === 'object' &&
                'toJSON' in body &&
                typeof body.toJSON === 'function' &&
                !(body instanceof Buffer) &&
                ((_a = body.constructor) === null || _a === void 0 ? void 0 : _a.name) !== 'FormData')));
    }
    async throwIfResponseIsError(options) {
        if (options.response.ok) {
            return;
        }
        throw await this.errorFromResponse(options);
    }
    async errorFromResponse({ response, parsedBody, }) {
        const codeByStatus = new Map([
            [401, 'UNAUTHENTICATED'],
            [403, 'FORBIDDEN'],
        ]);
        const code = codeByStatus.get(response.status);
        return new graphql_1.GraphQLError(`${response.status}: ${response.statusText}`, {
            extensions: {
                ...(code && { code }),
                response: {
                    url: response.url,
                    status: response.status,
                    statusText: response.statusText,
                    body: parsedBody,
                },
            },
        });
    }
    async head(path, request) {
        return (await this.fetch(path, { method: 'HEAD', ...request })).response;
    }
    async get(path, request) {
        return (await this.fetch(path, {
            method: 'GET',
            ...request,
        })).parsedBody;
    }
    async post(path, request) {
        return (await this.fetch(path, {
            method: 'POST',
            ...request,
        })).parsedBody;
    }
    async patch(path, request) {
        return (await this.fetch(path, {
            method: 'PATCH',
            ...request,
        })).parsedBody;
    }
    async put(path, request) {
        return (await this.fetch(path, {
            method: 'PUT',
            ...request,
        })).parsedBody;
    }
    async delete(path, request) {
        return (await this.fetch(path, {
            method: 'DELETE',
            ...request,
        })).parsedBody;
    }
    urlSearchParamsFromRecord(params) {
        const usp = new URLSearchParams();
        if (params) {
            for (const [name, value] of Object.entries(params)) {
                if (value !== undefined && value !== null) {
                    usp.set(name, value);
                }
            }
        }
        return usp;
    }
    async fetch(path, incomingRequest = {}) {
        var _a;
        const downcasedHeaders = {};
        if (incomingRequest.headers) {
            Object.entries(incomingRequest.headers).forEach(([key, value]) => {
                downcasedHeaders[key.toLowerCase()] = value;
            });
        }
        const augmentedRequest = {
            ...incomingRequest,
            params: incomingRequest.params instanceof URLSearchParams
                ? incomingRequest.params
                : this.urlSearchParamsFromRecord(incomingRequest.params),
            headers: downcasedHeaders,
        };
        if (!augmentedRequest.method)
            augmentedRequest.method = 'GET';
        if (this.willSendRequest) {
            await this.willSendRequest(path, augmentedRequest);
        }
        const url = await this.resolveURL(path, augmentedRequest);
        for (const [name, value] of augmentedRequest.params) {
            url.searchParams.append(name, value);
        }
        if (this.shouldJSONSerializeBody(augmentedRequest.body)) {
            augmentedRequest.body = JSON.stringify(augmentedRequest.body);
            if (!augmentedRequest.headers['content-type']) {
                augmentedRequest.headers['content-type'] = 'application/json';
            }
        }
        const outgoingRequest = augmentedRequest;
        const performRequest = async () => {
            return this.trace(url, outgoingRequest, async () => {
                var _a;
                const cacheKey = this.cacheKeyFor(url, outgoingRequest);
                const cacheOptions = outgoingRequest.cacheOptions
                    ? outgoingRequest.cacheOptions
                    : (_a = this.cacheOptionsFor) === null || _a === void 0 ? void 0 : _a.bind(this);
                try {
                    const { response, cacheWritePromise } = await this.httpCache.fetch(url, outgoingRequest, {
                        cacheKey,
                        cacheOptions,
                        httpCacheSemanticsCachePolicyOptions: outgoingRequest.httpCacheSemanticsCachePolicyOptions,
                    });
                    if (cacheWritePromise) {
                        this.catchCacheWritePromiseErrors(cacheWritePromise);
                    }
                    const parsedBody = await this.parseBody(response);
                    await this.throwIfResponseIsError({
                        url,
                        request: outgoingRequest,
                        response,
                        parsedBody,
                    });
                    return {
                        parsedBody: parsedBody,
                        response,
                        httpCache: {
                            cacheWritePromise,
                        },
                    };
                }
                catch (error) {
                    this.didEncounterError(error, outgoingRequest, url);
                    throw error;
                }
            });
        };
        const policy = this.requestDeduplicationPolicyFor(url, outgoingRequest);
        if (policy.policy === 'deduplicate-during-request-lifetime' ||
            policy.policy === 'deduplicate-until-invalidated') {
            const previousRequestPromise = this.deduplicationPromises.get(policy.deduplicationKey);
            if (previousRequestPromise)
                return previousRequestPromise.then((result) => this.cloneDataSourceFetchResult(result, {
                    policy,
                    deduplicatedAgainstPreviousRequest: true,
                }));
            const thisRequestPromise = performRequest();
            this.deduplicationPromises.set(policy.deduplicationKey, thisRequestPromise);
            try {
                return this.cloneDataSourceFetchResult(await thisRequestPromise, {
                    policy,
                    deduplicatedAgainstPreviousRequest: false,
                });
            }
            finally {
                if (policy.policy === 'deduplicate-during-request-lifetime') {
                    this.deduplicationPromises.delete(policy.deduplicationKey);
                }
            }
        }
        else {
            for (const key of (_a = policy.invalidateDeduplicationKeys) !== null && _a !== void 0 ? _a : []) {
                this.deduplicationPromises.delete(key);
            }
            return {
                ...(await performRequest()),
                requestDeduplication: {
                    policy,
                    deduplicatedAgainstPreviousRequest: false,
                },
            };
        }
    }
    catchCacheWritePromiseErrors(cacheWritePromise) {
        cacheWritePromise.catch((e) => {
            this.logger.error(`Error writing from RESTDataSource to cache: ${e}`);
        });
    }
    async trace(url, request, fn) {
        if (NODE_ENV === 'development') {
            const startTime = Date.now();
            try {
                return await fn();
            }
            finally {
                const duration = Date.now() - startTime;
                const label = `${request.method || 'GET'} ${url}`;
                this.logger.info(`${label} (${duration}ms)`);
            }
        }
        else {
            return fn();
        }
    }
}
exports.RESTDataSource = RESTDataSource;
//# sourceMappingURL=RESTDataSource.js.map