"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPCache = void 0;
const node_fetch_1 = __importStar(require("node-fetch"));
const http_cache_semantics_1 = __importDefault(require("http-cache-semantics"));
const utils_keyvaluecache_1 = require("@apollo/utils.keyvaluecache");
class HTTPCache {
    constructor(keyValueCache = new utils_keyvaluecache_1.InMemoryLRUCache(), httpFetch = node_fetch_1.default) {
        this.keyValueCache = new utils_keyvaluecache_1.PrefixingKeyValueCache(keyValueCache, 'httpcache:');
        this.httpFetch = httpFetch;
    }
    async fetch(url, requestOpts = {}, cache) {
        var _a, _b;
        const urlString = url.toString();
        requestOpts.method = (_a = requestOpts.method) !== null && _a !== void 0 ? _a : 'GET';
        const cacheKey = (_b = cache === null || cache === void 0 ? void 0 : cache.cacheKey) !== null && _b !== void 0 ? _b : urlString;
        if (requestOpts.method === 'HEAD') {
            return { response: await this.httpFetch(urlString, requestOpts) };
        }
        const entry = await this.keyValueCache.get(cacheKey);
        if (!entry) {
            const response = await this.httpFetch(urlString, requestOpts);
            const policy = new http_cache_semantics_1.default(policyRequestFrom(urlString, requestOpts), policyResponseFrom(response), cache === null || cache === void 0 ? void 0 : cache.httpCacheSemanticsCachePolicyOptions);
            return this.storeResponseAndReturnClone(urlString, response, requestOpts, policy, cacheKey, cache === null || cache === void 0 ? void 0 : cache.cacheOptions);
        }
        const { policy: policyRaw, ttlOverride, body } = JSON.parse(entry);
        const policy = http_cache_semantics_1.default.fromObject(policyRaw);
        const urlFromPolicy = policy._url;
        policy._url = undefined;
        if ((ttlOverride && policy.age() < ttlOverride) ||
            (!ttlOverride &&
                policy.satisfiesWithoutRevalidation(policyRequestFrom(urlString, requestOpts)))) {
            const headers = policy.responseHeaders();
            return {
                response: new node_fetch_1.Response(body, {
                    url: urlFromPolicy,
                    status: policy._status,
                    headers: cachePolicyHeadersToNodeFetchHeadersInit(headers),
                }),
            };
        }
        else {
            const revalidationHeaders = policy.revalidationHeaders(policyRequestFrom(urlString, requestOpts));
            const revalidationRequest = {
                ...requestOpts,
                headers: cachePolicyHeadersToFetcherHeadersInit(revalidationHeaders),
            };
            const revalidationResponse = await this.httpFetch(urlString, revalidationRequest);
            const { policy: revalidatedPolicy, modified } = policy.revalidatedPolicy(policyRequestFrom(urlString, revalidationRequest), policyResponseFrom(revalidationResponse));
            return this.storeResponseAndReturnClone(urlString, new node_fetch_1.Response(modified ? await revalidationResponse.text() : body, {
                url: revalidatedPolicy._url,
                status: revalidatedPolicy._status,
                headers: cachePolicyHeadersToNodeFetchHeadersInit(revalidatedPolicy.responseHeaders()),
            }), requestOpts, revalidatedPolicy, cacheKey, cache === null || cache === void 0 ? void 0 : cache.cacheOptions);
        }
    }
    async storeResponseAndReturnClone(url, response, request, policy, cacheKey, cacheOptions) {
        if (typeof cacheOptions === 'function') {
            cacheOptions = await cacheOptions(url, response, request);
        }
        let ttlOverride = cacheOptions === null || cacheOptions === void 0 ? void 0 : cacheOptions.ttl;
        if (!(ttlOverride && policy._status >= 200 && policy._status <= 299) &&
            !(request.method === 'GET' && policy.storable())) {
            return { response };
        }
        let ttl = ttlOverride === undefined
            ? Math.round(policy.timeToLive() / 1000)
            : ttlOverride;
        if (ttl <= 0)
            return { response };
        if (canBeRevalidated(response)) {
            ttl *= 2;
        }
        const returnedResponse = response.clone();
        return {
            response: returnedResponse,
            cacheWritePromise: this.readResponseAndWriteToCache({
                response,
                policy,
                cacheOptions,
                ttl,
                ttlOverride,
                cacheKey,
            }),
        };
    }
    async readResponseAndWriteToCache({ response, policy, cacheOptions, ttl, ttlOverride, cacheKey, }) {
        const body = await response.text();
        const entry = JSON.stringify({
            policy: policy.toObject(),
            ttlOverride,
            body,
        });
        await this.keyValueCache.set(cacheKey, entry, {
            ...cacheOptions,
            ttl,
        });
    }
}
exports.HTTPCache = HTTPCache;
function canBeRevalidated(response) {
    return response.headers.has('ETag') || response.headers.has('Last-Modified');
}
function policyRequestFrom(url, request) {
    var _a, _b;
    return {
        url,
        method: (_a = request.method) !== null && _a !== void 0 ? _a : 'GET',
        headers: (_b = request.headers) !== null && _b !== void 0 ? _b : {},
    };
}
function policyResponseFrom(response) {
    return {
        status: response.status,
        headers: response.headers instanceof node_fetch_1.Headers &&
            'raw' in response.headers
            ? nodeFetchHeadersToCachePolicyHeaders(response.headers)
            : Object.fromEntries(response.headers),
    };
}
function nodeFetchHeadersToCachePolicyHeaders(headers) {
    const cachePolicyHeaders = Object.create(null);
    for (const [name, values] of Object.entries(headers.raw())) {
        cachePolicyHeaders[name] = values.length === 1 ? values[0] : values;
    }
    return cachePolicyHeaders;
}
function cachePolicyHeadersToNodeFetchHeadersInit(headers) {
    const headerList = [];
    for (const [name, value] of Object.entries(headers)) {
        if (Array.isArray(value)) {
            for (const subValue of value) {
                headerList.push([name, subValue]);
            }
        }
        else if (value) {
            headerList.push([name, value]);
        }
    }
    return headerList;
}
function cachePolicyHeadersToFetcherHeadersInit(headers) {
    const headerRecord = Object.create(null);
    for (const [name, value] of Object.entries(headers)) {
        if (Array.isArray(value)) {
            headerRecord[name] = value.join(', ');
        }
        else if (value) {
            headerRecord[name] = value;
        }
    }
    return headerRecord;
}
//# sourceMappingURL=HTTPCache.js.map